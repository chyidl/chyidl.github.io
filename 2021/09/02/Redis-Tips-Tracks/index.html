

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="chyi">
  <meta name="keywords" content="">
  
    <meta name="description" content="Redis Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker.">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis Tips &amp; Tracks">
<meta property="og:url" content="http://chyidl.github.io/2021/09/02/Redis-Tips-Tracks/">
<meta property="og:site_name" content="Stay Hungry Stay Foolish">
<meta property="og:description" content="Redis Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://chyidl.github.io/misc/images/redis-knowledge.jpg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/redis-problems.jpeg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/redis-epoll.jpg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/bgrewriteaof.jpg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/redis-cow.jpg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/master-slave-sync.jpg">
<meta property="og:image" content="http://chyidl.github.io/misc/images/redis-sentinel.jpg">
<meta property="article:published_time" content="2021-09-02T13:55:16.000Z">
<meta property="article:modified_time" content="2022-01-05T08:13:40.870Z">
<meta property="article:author" content="chyi">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://chyidl.github.io/misc/images/redis-knowledge.jpg">
  
  
  <title>Redis Tips &amp; Tracks - Stay Hungry Stay Foolish</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"chyidl.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Stay Hungry Stay Foolish" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis Tips &amp; Tracks">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-02 21:55" pubdate>
        2021年9月2日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis Tips &amp; Tracks</h1>
            
            <div class="markdown-body">
              <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker.</p>
</blockquote>
<span id="more"></span>

<h2 id="Redis知识的全景图"><a href="#Redis知识的全景图" class="headerlink" title="Redis知识的全景图"></a>Redis知识的全景图</h2><p><img src="/misc/images/redis-knowledge.jpg" srcset="/img/loading.gif" lazyload alt="Redis 知识全景图"></p>
<ul>
<li>应用纬度:<ul>
<li>缓存应用<ul>
<li>内嵌Key过期机制和淘汰策略</li>
</ul>
</li>
<li>集群应用<ul>
<li>主从集群、切片集群</li>
</ul>
</li>
<li>数据结构应用<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>Sorted Set</li>
</ul>
</li>
</ul>
</li>
<li>系统纬度:<ul>
<li>处理层:<ul>
<li>线程模型</li>
</ul>
</li>
<li>内存层:<ul>
<li>数据结构</li>
</ul>
</li>
<li>存储层:<ul>
<li>AOF</li>
<li>RDB</li>
</ul>
</li>
<li>网络层:<ul>
<li>epool网络框架</li>
</ul>
</li>
</ul>
</li>
<li>高性能主线:<ul>
<li>线程模型</li>
<li>数据结构<ul>
<li>集合类型采用有序索引，可以支持范围操作</li>
<li>考虑不同数据结构的内存效率、设计了压缩列表、整数数组这些精简的底层数据结构、节省内存开销</li>
</ul>
</li>
<li>内存分配器<ul>
<li>jemalloc和tcmalloc比glibc效率高</li>
</ul>
</li>
<li>持久化<ul>
<li>支持RDB、AOF持久化数据，支持主从库集群</li>
</ul>
</li>
<li>网络框架</li>
</ul>
</li>
<li>高可用主线:<ul>
<li>主从复制</li>
<li>哨兵机制</li>
<li>切片集群</li>
</ul>
</li>
<li>高扩展主线:<ul>
<li>数据分片</li>
<li>负载均衡</li>
</ul>
</li>
</ul>
<h2 id="Redis问题画像图"><a href="#Redis问题画像图" class="headerlink" title="Redis问题画像图"></a>Redis问题画像图</h2><p><img src="/misc/images/redis-problems.jpeg" srcset="/img/loading.gif" lazyload alt="Redis问题画像"></p>
<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><ul>
<li><p>基础架构</p>
<figure class="highlight haml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><pre><code class="hljs haml"># 数据模型: key-value<br>  &gt; Redis能够在实际业务场景中广泛的应用，就是得益于支持多样化类型的value<br><br># 操作接口:<br>  -<span class="ruby"> <span class="hljs-symbol">PUT:</span></span><br><span class="ruby"></span>  -<span class="ruby"> <span class="hljs-symbol">GET:</span></span><br><span class="ruby"></span>  -<span class="ruby"> <span class="hljs-symbol">DELETE:</span></span><br><span class="ruby"></span>  -<span class="ruby"> <span class="hljs-symbol">SCAN:</span></span><br><span class="ruby"></span><br># 访问框架:<br>  -<span class="ruby"> 动态库访问</span><br><span class="ruby"></span>  -<span class="ruby"> 网络框架访问<span class="hljs-symbol">:</span>包括Socket Server和协议解析</span><br><span class="ruby"></span># 操作模块:<br>  -<span class="ruby"> Redis 键-值映射数据类型</span><br><span class="ruby"></span>    -<span class="ruby"> 哈希表: 就是一个数组，数组的每个元素netry称为一个哈希桶(桶中元素存储的是指向key和value的指针).</span><br><span class="ruby"></span>      -<span class="ruby"> O(<span class="hljs-number">1</span>)时间复杂度快速查找键值对</span><br><span class="ruby"></span>      -<span class="ruby"> 哈希表冲突问题</span><br><span class="ruby"></span>        -<span class="ruby"> Redis解决哈希冲突使用链式哈希,指向同一个哈希桶中的多个元素用链表保存，之间依次用指针连接</span><br><span class="ruby"></span>      -<span class="ruby"> Rehash操作:</span><br><span class="ruby"></span>        -<span class="ruby"> 装载因子 load factor = 所有entry个数/哈希表的哈希桶个数</span><br><span class="ruby"></span>        -<span class="ruby"> rehash操作就是增加现有哈希桶数量，让增多的entry元素能在更多的桶之间分散保存，减少单个桶中元素数量,从而减少单个桶中冲突</span><br><span class="ruby"></span>        -<span class="ruby"> Redis默认采用两个全局哈希表,哈希表<span class="hljs-number">1</span>，哈希表<span class="hljs-number">2</span>, Rehash过程:</span><br><span class="ruby"></span>          -<span class="ruby"> hash2分配更大空间 <span class="hljs-number">2</span> * hash1</span><br><span class="ruby"></span>          -<span class="ruby"> 将hash1中数据重新映射并拷贝到hash2</span><br><span class="ruby"></span>          -<span class="ruby"> 释放hash1空间</span><br><span class="ruby"></span>        -<span class="ruby"> 渐进式<span class="hljs-symbol">rehash:</span></span><br><span class="ruby"></span>          -<span class="ruby"> 巧妙的把一次性大量拷贝的开销分摊到多次处理请求的过程中，避免耗时操作，保证数据的快速访问</span><br><span class="ruby"></span><br>  -<span class="ruby"> Redis值的数据类型:</span><br><span class="ruby"></span>    -<span class="ruby"> 字符串<span class="hljs-symbol">String:</span></span><br><span class="ruby"></span>      -<span class="ruby"> 底层数据类型:</span><br><span class="ruby"></span>        -<span class="ruby"> 简单动态字符串</span><br><span class="ruby"></span>    -<span class="ruby"> 列表List</span><br><span class="ruby"></span>      -<span class="ruby"> 底层数据类型:</span><br><span class="ruby"></span>        -<span class="ruby"> 双向链表</span><br><span class="ruby"></span>        -<span class="ruby"> 压缩列表</span><br><span class="ruby"></span>    -<span class="ruby"> 集合Set</span><br><span class="ruby"></span>      -<span class="ruby"> 底层数据类型</span><br><span class="ruby"></span>        -<span class="ruby"> 压缩列表</span><br><span class="ruby"></span>        -<span class="ruby"> 整数数组</span><br><span class="ruby"></span>    -<span class="ruby"> 有序集合Sorted Set</span><br><span class="ruby"></span>      -<span class="ruby"> 底层数据类型</span><br><span class="ruby"></span>        -<span class="ruby"> 压缩列表</span><br><span class="ruby"></span>        -<span class="ruby"> 跳表</span><br><span class="ruby"></span>    -<span class="ruby"> 哈希Hash</span><br><span class="ruby"></span>      -<span class="ruby"> 底层数据类型</span><br><span class="ruby"></span>        -<span class="ruby"> 压缩列表</span><br><span class="ruby"></span>        -<span class="ruby"> 哈希表</span><br><span class="ruby"></span>  -<span class="ruby"> Redis底层数据结构</span><br><span class="ruby"></span>    &gt; Redis之所以采用不同的数据结构，是在性能和内存使用效率之间进行平衡<br>    -<span class="ruby"> 简单动态字符串</span><br><span class="ruby"></span>    -<span class="ruby"> 双向链表</span><br><span class="ruby"></span>    -<span class="ruby"> 压缩列表<span class="hljs-symbol">:</span>类似数组</span><br><span class="ruby"></span>      -<span class="ruby"> 表头:</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-symbol">zlbytes:</span> 列表长度</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-symbol">zltail:</span> 列表尾的偏移量</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-symbol">zllen:</span> 列表中entry个数</span><br><span class="ruby"></span>      -<span class="ruby"> 表尾:</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-symbol">zlend:</span> 表示结束</span><br><span class="ruby"></span>    -<span class="ruby"> 哈希表</span><br><span class="ruby"></span>    -<span class="ruby"> 跳表: 跳表在链表的基础上增加多级索引，通过索引位置的几个跳转，实现数据的快速定位</span><br><span class="ruby"></span>      -<span class="ruby"> 查找复杂度O(logN)</span><br><span class="ruby"></span>    -<span class="ruby"> 整数数组</span><br><span class="ruby"></span><br># 索引模块:<br>  -<span class="ruby"> 索引的作用是让键值数据库根据Key找到响应value的存储位置，进而执行操作</span><br><span class="ruby"></span>  -<span class="ruby"> 哈希表: redis, mamcached采用</span><br><span class="ruby"></span>    -<span class="ruby"> 内存的高性能随机访问可以很好与哈希表O(<span class="hljs-number">1</span>)操作复杂度相匹配</span><br><span class="ruby"></span>  -<span class="ruby"> B+树</span><br><span class="ruby"></span>  -<span class="ruby"> 字典树</span><br><span class="ruby"></span>  -<span class="ruby"> skip <span class="hljs-symbol">list:</span> RocksDB采用</span><br><span class="ruby"></span># 存储模块:<br>  -<span class="ruby"> 内存分配器</span><br><span class="ruby"></span>    -<span class="ruby"> <span class="hljs-symbol">glibc:</span> malloc/free</span><br><span class="ruby"></span>  -<span class="ruby"> 持久化</span><br><span class="ruby"></span>    -<span class="ruby"> 日志AOF</span><br><span class="ruby"></span>    -<span class="ruby"> 快照RDB</span><br><span class="ruby"></span># IO模型设计<br>  &gt; Redis单线程是指网络IO和键值对读写是由一个线程完成. 其他功能持久化、异步删除、集群数据同步是由额外的线程执行.<br>  -<span class="ruby"> 多线程编程模式:</span><br><span class="ruby"></span>    -<span class="ruby"> 面临共享资源的并发访问控制问题</span><br><span class="ruby"></span>    -<span class="ruby"> 采用多线程开发会引入同步原语来保护共享资源的并发访问</span><br><span class="ruby"></span>  -<span class="ruby"> 单线程编程模式:</span><br><span class="ruby"></span>    -<span class="ruby"> Redis基本IO模型中，主要是主线程在执行操作，任何耗时的操作，bigkey、全量返回等操作，都是潜在的性能瓶颈</span><br></code></pre></td></tr></table></figure></li>
<li><p>Socker网络模型</p>
<table>
<thead>
<tr>
<th align="left">调用方法</th>
<th align="left">返回套接字类型</th>
<th align="left">非阻塞模式</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">socket()</td>
<td align="left">主动套接字</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">listen()</td>
<td align="left">监听套接字</td>
<td align="left">可设置</td>
<td align="left">accept()非阻塞</td>
</tr>
<tr>
<td align="left">accept()</td>
<td align="left">已连接套接字</td>
<td align="left">可设置</td>
<td align="left">send()/recv()非阻塞</td>
</tr>
</tbody></table>
</li>
<li><p>Redis多路复用IO模型<br><img src="/misc/images/redis-epoll.jpg" srcset="/img/loading.gif" lazyload alt="基于多路复用的Redis高性能IO模型"></p>
<blockquote>
<p>一个线程处理多个IO流.该机制允许内核中同时存在多个监听套接字和已连接套接字.<br>select/epoll提供基于事件的回调机制，针对不同事件的发生，调用响应的处理函数</p>
</blockquote>
</li>
<li><p>底层数据结构时间复杂度分类</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">哈希表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">跳表</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">双向链表</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">压缩列表</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">整数数组</td>
<td align="left">O(N)</td>
</tr>
</tbody></table>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 单元素操作是基础</span><br><span class="hljs-meta"># 范围操作非常耗时</span><br>  - 范围操作是指集合类型中的遍历操作: O(N)<br>  - SCAN操作实现渐进式遍历，只返回有限数量的数据.<br><span class="hljs-meta"># 统计操作通常高校</span><br>  压缩列表和双向链表都会记录表头和表尾的偏移量<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li>通信协议<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis客户端和服务器发送的命令和数据一律以\r\n (CR LF)结尾<br><br><span class="hljs-comment"># 请求协议:</span><br>  *&lt;参数数量&gt; CR LF<br>  $&lt;参数的字节数量&gt; CR LF<br>  &lt;参数的数据&gt; CR LF<br><br>  ubuntu <span class="hljs-keyword">in</span> /  at 3BPlus took 11s<br>  ➜ tail appendonly.aof<br>  <span class="hljs-number">*3</span>        - 表示当前命令有单个部分<br>  <span class="hljs-variable">$3</span>        - 字节数<br>  <span class="hljs-builtin-name">set</span><br>  <span class="hljs-variable">$4</span><br>  name<br>  <span class="hljs-variable">$10</span><br>  chyiyaqing<br><br><span class="hljs-comment"># 回复协议:</span><br>  &gt; 在回复协议中，可以通过检查第一个字节，确定这个回复是什么类型<br>  - 状态回复 (status reply) 第一个字节是 <span class="hljs-string">&quot;+&quot;</span><br>  - 错误回复 (<span class="hljs-builtin-name">error</span> reply) 第一个字节是 <span class="hljs-string">&quot;-&quot;</span><br>  - 整数回复 (integer reply) 第一个字节是 <span class="hljs-string">&quot;.&quot;</span><br>  - 批量回复 (bulk reply) 第一个字节是 <span class="hljs-string">&quot;$&quot;</span><br>  - 多条批量回复 (multi bulk reply) 第一个字节是 <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><blockquote>
<p>Redis 持久化主要两大机制: AOF (Append Only File) 日志和RDB 快照</p>
</blockquote>
<ul>
<li><p>AOF - Append Only File</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">AOF日志是Redis执行完命令，把数据写入内存，然后才记录日志,避免出现记录错误命令的情况,记录的是Redis收到的每一条命令, 这些命令以文本形式保存</span><br></code></pre></td></tr></table></figure>
<ul>
<li>AOF 潜在的风险<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 执行完命令还没有来得及记日志就宕机，这个命令和相关的数据有丢失的风险?<br><span class="hljs-bullet">-</span> AOF写日志在主线程中执行，如果磁盘写压力过大，就会导致写盘很慢，进而导致后续的操作无法执行<br><span class="hljs-section"># 写回磁盘策略 appendfsync</span><br><span class="hljs-bullet">  1.</span> Always: 同步写回, 每个写命令执行完，立马同步将日志写回磁盘<br><span class="hljs-code">    &gt; 落盘操作属于慢速，回影响主线程性能</span><br><span class="hljs-code">  2. Everysec: 每秒写回,每个写命令执行完，先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</span><br><span class="hljs-code">    &gt; 在避免影响主线程和避免数据丢失两者之间trade-off方式</span><br><span class="hljs-code">  3. No: 操作系统控制写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="hljs-code">    &gt; 落盘时机交给操作系统，只要AOF记录没有写回磁盘，宕机对应的数据就丢失</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">写回时机</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Always</td>
<td align="left">同步写回</td>
<td align="left">可靠性高，数据基本不丢失</td>
<td align="left">每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td align="left">EverySec</td>
<td align="left">每秒写回</td>
<td align="left">性能适中</td>
<td align="left">宕机时丢失1秒内的数据</td>
</tr>
<tr>
<td align="left">No</td>
<td align="left">操作系统控制写回</td>
<td align="left">性能好</td>
<td align="left">宕机丢失数据较多</td>
</tr>
</tbody></table>
</li>
<li>AOF文件过大的性能问题<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 文件系统本身对文件大小有限制，无法保存过大的文件<br><span class="hljs-bullet">2.</span> 文件过大，追加命令记录效率变低<br><span class="hljs-bullet">3.</span> 发生宕机，AOF记录命令要被重新执行，故障恢复比较缓慢，会影响Redis正常使用<br></code></pre></td></tr></table></figure></li>
<li>AOF重写机制:<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">直接根据数据库中数据的最新状态，生成这些数据的插入命令<br><span class="hljs-quote">&gt; 重写机制可以将旧日志文件中的多条命令，在重写后的新日志中变成一条命令</span><br><span class="hljs-quote">&gt; AOF重写过程是由后台子进程bgrewriteaof完成，避免阻塞主线程，导致性能下降</span><br><span class="hljs-bullet">-</span> &quot;一个拷贝，两处日志&quot;<br><span class="hljs-bullet">  -</span> 一个拷贝: 每次执行重写时，主线程fork出后台的bgrewriteaof子进程，此时，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，然后bgrewriteaof子进程在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志.<br><span class="hljs-bullet">  -</span> 两处日志: 一个是正在使用的AOF日志，Redis会把操作写到它的缓冲区，第二处日志是新的AOF重写日志，等到拷贝数据的所有操作记录重写完成后，重写日志记录的操作也会写入新的AOF文件，保证数据库最新状态的记录<br></code></pre></td></tr></table></figure>
<img src="/misc/images/bgrewriteaof.jpg" srcset="/img/loading.gif" lazyload alt="AOF非阻塞重写过程"></li>
</ul>
</li>
<li><p>RDB(Redis DataBase) - 内存快照</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">内存快照：指内存中的数据在某一个时刻的状态记录</span><br></code></pre></td></tr></table></figure>
<ul>
<li>Redis两种命令生成RDB文件<ul>
<li>save: 在主线程执行，会导致阻塞</li>
<li>bgsave: 创建子进程，专门用于写入RDB文件，避免主线程阻塞, 默认配置<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; bgsave子进程由主线程fork生成，共享主线程的所有内存数据，bgsave子进程运行后，开始读取主线程的内存数据，并把数据写入RDB文件</span><br><span class="hljs-bullet">  1.</span> 频繁将全量数据写入磁盘，会给磁盘带来很大压力.<br><span class="hljs-bullet">  2.</span> bgsave子进程需要fork操作从主线程创建出来, fork操作会阻塞主线程<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>COW - Copy-On-Write<br><img src="/misc/images/redis-cow.jpg" srcset="/img/loading.gif" lazyload alt="写时复制机制"><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">写时复制技术具体来说，主线程在有写操作时，才会把这个新写或者修改的数据写入到新的物理地址,并修改自己的页表映射.<br>保证快照的完整性，也允许主线程同时对数据进行修改，避免对正常业务的影响<br></code></pre></td></tr></table></figure></li>
<li>Redis 4.0 混合AOF+RDB<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 增量快照:</span><br><span class="hljs-quote">&gt; 做一次全量快照后，后续的快照支队修改的数据进行快照记录，可以避免每次全量快照的开销</span><br><br><span class="hljs-section"># 混合使用AOF日志和内存快照</span><br><span class="hljs-quote">&gt; 内存快照以一定的频率执行，两次快照之间，使用AOF日志记录这期间的所有命令操作</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><ul>
<li>Redis 主从库模式<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 主从库采用读写分离方式</span><br><span class="hljs-bullet">  -</span> 读操作: 主库、从库都可以接收<br><span class="hljs-bullet">  -</span> 写操作: 首先到主库执行，然后，主库将写操作同步给从库<br></code></pre></td></tr></table></figure>
<ul>
<li>主从库如何进行第一次同步?<br><img src="/misc/images/master-slave-sync.jpg" srcset="/img/loading.gif" lazyload alt="主从库第一次同步流程"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 三个阶段</span><br><span class="hljs-bullet">  1.</span> 第一阶段: 建立连接、协商同步<br><span class="hljs-bullet">    -</span> psync ? -1<br><span class="hljs-bullet">    -</span> runID: Redis实例自动生成的随机ID<br><span class="hljs-bullet">    -</span> offset: 复制的偏移量<br><span class="hljs-bullet">    -</span> FULLRESYNC: 表示第一次复制采用全量复制，主库会把当前所有的数据都复制给从库<br><span class="hljs-bullet">  2.</span> 第二阶段: 主库同步数据给从库<br><span class="hljs-bullet">    -</span> 主库将所有数据同步给从库,从库收到数据后，在本地完成数据加载<br><span class="hljs-bullet">    -</span> replication buffer: 主从库在进行全量复制时，主库上用于和从库连接的客户端buffer<br><span class="hljs-bullet">  3.</span> 第三阶段: 主库发送新写命令给从库<br><span class="hljs-bullet">    -</span> 主库把replication buffer 操作发给从库<br><span class="hljs-bullet">    -</span> 主库会给每个从库建立一个客户端，所以replication buffer不是共享的，而是每个从库都有一个对应的客户端<br><br><span class="hljs-section"># 主从库复制采用RDB,不采用AOF?</span><br><span class="hljs-bullet">  1.</span> RDB 文件是二进制文件，无论要把RDB写入磁盘还是通过网络传输RDB，IO效率比记录的纯文本AOF高<br><span class="hljs-bullet">  2.</span> 在从库进行恢复时，用RDB的恢复效率比AOF高<br></code></pre></td></tr></table></figure></li>
<li>主 - 从 - 从<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库中</span><br></code></pre></td></tr></table></figure></li>
<li>基于长连接的命令传播<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># repl_backlog_size:</span><br><span class="hljs-meta"># repl_backlog_buffer: 为了支持从库增量复制，主库上用于持续保持写操作的一块专用buffer, 所有从库共享</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>哨兵机制<br><img src="/misc/images/redis-sentinel.jpg" srcset="/img/loading.gif" lazyload alt="哨兵机制任务"><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haml">  &gt; Redis主从集群中，哨兵机制实现主从库自动切换, 解决主从复制模式下故障转移<br>  # 哨兵集群:<br>    &gt; 采用多实例组成的集群模式进行部署, 引入多哨兵判断避免单个哨兵自身网络状态不好，误判主库下线<br>    &gt; N个哨兵实例，最好要有N/2+1实例判断主库为&quot;主观下线&quot;, 最终判定主库为“客观下线”<br><br>  # 哨兵负责的任务:<br>    -<span class="ruby"> 监控</span><br><span class="ruby"></span>      -<span class="ruby"> 周期性向所有的主从库发送PING命令</span><br><span class="ruby"></span>      -<span class="ruby"> 哨兵对主库下线判断:</span><br><span class="ruby"></span>        -<span class="ruby"> 主观下线: 哨兵进程使用PING命令检测自己和主、从库的网络连接情况，判断实例的状态</span><br><span class="ruby"></span>          -<span class="ruby"> 误判: 发生在集群网络压力较大、网络拥赛，或者主库本身压力较大</span><br><span class="ruby"></span>        -<span class="ruby"> 客观下线:</span><br><span class="ruby"></span>    -<span class="ruby"> 选主</span><br><span class="ruby"></span>      -<span class="ruby"> 主库挂了之后，哨兵需要从很多从库中选择一个从库实例</span><br><span class="ruby"></span>      -<span class="ruby"> <span class="hljs-string">&quot;筛选&quot;</span> + <span class="hljs-string">&quot;打分&quot;</span>:</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-string">&quot;筛选&quot;</span>: 检查从库的当前在线状态，判断网络连接状态</span><br><span class="ruby"></span>        -<span class="ruby"> <span class="hljs-string">&quot;打分&quot;</span>: 从库优先级、从库复制进度以及从库ID号</span><br><span class="ruby"></span>          -<span class="ruby"> replica-priority <span class="hljs-number">100</span></span><br><span class="ruby"></span>    -<span class="ruby"> 通知</span><br><span class="ruby"></span>      -<span class="ruby"> 哨兵会把新主库的连接信息发给其他从库，让他们执行replicaof命令，和新主库建立连接，并进行数据复制,同时哨兵把新主库的连接信息通知给客户端，请求操作发到新主库上.</span><br><span class="ruby"></span><br># 基于pub/sub 机制的哨兵集群<br>  &gt; 哨兵只要和主库建立连接，就可以在主库上发布消息，比如发布自己的连接信息(IP和端口),从主库上订阅消息，获取其他哨兵发布的连接信息<br><br>  -<span class="ruby"> 哨兵获取从库的IP+端口</span><br><span class="ruby"></span>    -<span class="ruby"> 哨兵向主库发送INFO命令,查看从库列表,进而与从库建立连接</span><br><span class="ruby"></span>  -<span class="ruby"> pub/sub客户端事件通知</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis切片集群"><a href="#Redis切片集群" class="headerlink" title="Redis切片集群"></a>Redis切片集群</h2>  <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">切片集群(分片集群)可以保存大量数据，对Redis主线程阻塞影响较小</span><br></code></pre></td></tr></table></figure>
<ul>
<li>纵向扩展(scale up):</li>
<li>横向扩展(scale out):<ul>
<li>Redis Cluster:<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vala">&gt; Redis Cluster 采用哈希槽(Hash Slot)处理数据和实例之间的映射关系. <span class="hljs-number">2</span>^<span class="hljs-number">14</span><br><br><span class="hljs-meta"># key映射哈希slot</span><br>  <span class="hljs-number">1.</span> 根据键值key，按照CRC16算法计算<span class="hljs-number">16</span>-bit值，然后对<span class="hljs-number">16384</span>取模,每个摸数代表响应编号的哈希槽。<br><br><span class="hljs-meta"># 重定向机制</span><br>  &gt; 客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令<br>  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; <span class="hljs-keyword">get</span> name<br>  -&gt; Redirected to slot [<span class="hljs-number">5798</span>] located at <span class="hljs-number">172.30</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:<span class="hljs-number">6002</span><br>  <span class="hljs-string">&quot;chyiyaqing&quot;</span><br>  <span class="hljs-number">172.30</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:<span class="hljs-number">6002</span>&gt;<br><br><span class="hljs-meta"># ASK:</span><br>  ASK命令并不会更新客户端缓存的哈希槽分配信息<br><span class="hljs-meta"># MOVED:</span><br>  更改本地缓存，让后续所有命令都发往新实例<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Redis-应用场景-消息队列"><a href="#Redis-应用场景-消息队列" class="headerlink" title="Redis 应用场景 - 消息队列"></a>Redis 应用场景 - 消息队列</h2>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 消息队列需要满足的功能:</span><br><br><span class="hljs-bullet">  1.</span> 支持阻塞等待拉取消息<br><span class="hljs-bullet">  2.</span> 支持发布/订阅模式<br><span class="hljs-bullet">  3.</span> 消费失败，可重新消费，消息不丢失<br><span class="hljs-bullet">  4.</span> 实例宕机，消息不丢失、数据可持久化<br><span class="hljs-bullet">  5.</span> 消息可堆积<br></code></pre></td></tr></table></figure>

<ul>
<li><p>List - 队列:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">ubuntu in ~ at 3BPlus<br>➜ redis-cli -c -p <span class="hljs-number">6001</span><br><span class="hljs-number">127.0.0.1:6001</span>&gt; ping<br>PONG<br><span class="hljs-number">127.0.0.1:6001</span>&gt; LPUSH queue msg1    # 增加消息<br>-&gt; Redirected to slot <span class="hljs-string">[13011]</span> located at <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6003</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">172.30.1.23:6003</span>&gt; LPUSH queue msg2<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">172.30.1.23:6003</span>&gt; RPOP queue        # 拉取消息<br><span class="hljs-string">&quot;msg1&quot;</span><br><span class="hljs-number">172.30.1.23:6003</span>&gt; RPOP queue<br><span class="hljs-string">&quot;msg2&quot;</span><br><span class="hljs-number">127.0.0.1:6001</span>&gt; RPOP queue          # 队列为空，RPOP返回NULL<br>-&gt; Redirected to slot <span class="hljs-string">[13011]</span> located at <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6003</span><br>(nil)<br><span class="hljs-number">127.0.0.1:6001</span>&gt; BRPOP queue <span class="hljs-number">5</span>       # BRPOP阻塞式拉取消息，支持传入超时时间<br>-&gt; Redirected to slot <span class="hljs-string">[13011]</span> located at <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6003</span><br>(nil)<br>(<span class="hljs-number">5</span>.00s)<br><span class="hljs-number">172.30.1.23:6003</span>&gt; BRPOP queue <span class="hljs-number">0</span>     # 不设置超时，直到有新消息才返回<br>^C<br><span class="hljs-number">172.30.1.23:6003</span>&gt; exit<br><br>注意: 如果设置超时时间太长，连接太久没有活跃，有可能会被Redis server判定为无效连接，之后Redis Server会强制把这个客户端踢下线，客户端要有重连机制<br><br><span class="hljs-number">1</span>. 不支持重复消费：消费者拉取消息后，该消息就从List中删除，无法被其他消费者在此消费，即不支持多个消费者消费同一批数据<br><span class="hljs-number">2</span>. 消息丢失，消费者拉取到消息后，如果发生异常宕机，这条消息就丢失<br><br># 单机测评<br>ubuntu in ~ at 3BPlus took 37s<br>➜ redis-benchmark -n <span class="hljs-number">1000000</span> -t lpush,rpop -P <span class="hljs-number">16</span> -q -h <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">6001</span> --cluster<br>Cluster has <span class="hljs-number">3</span> master nodes:<br><br>Master <span class="hljs-number">0</span>: a733c21d3b735b9d026eb4d462ef6b367d8ebb98 <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6002</span><br>Master <span class="hljs-number">1</span>: 9c35a4e211f6534861ed768dba592e85539b1377 <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6003</span><br>Master <span class="hljs-number">2</span>: a901e497cb72819cf0765e9e4eb16c36399c437b <span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">1</span>.<span class="hljs-number">23</span>:<span class="hljs-number">6001</span><br><br>LPUSH: <span class="hljs-number">41529</span>.<span class="hljs-number">96</span> requests per second, p50=<span class="hljs-number">17</span>.<span class="hljs-number">199</span> msec<br>RPOP: <span class="hljs-number">46539</span>.<span class="hljs-number">77</span> requests per second, p50=<span class="hljs-number">15</span>.<span class="hljs-number">463</span> msec<br></code></pre></td></tr></table></figure></li>
<li><p>Pub/Sub - 发布订阅模型</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 消费者1</span><br>ubuntu <span class="hljs-keyword">in</span> ~ <span class="hljs-keyword">at</span> <span class="hljs-number">3</span>BPlus<br>➜ redis-cli -c -p <span class="hljs-number">6001</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; SUBSCRIBE queue<br>Reading messages... (press Ctrl-C <span class="hljs-keyword">to</span> quit)<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;subscribe&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue&quot;</span><br><span class="hljs-number">3</span>) (<span class="hljs-built_in">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;msg1&quot;</span><br><br><span class="hljs-comment"># 消费者2</span><br>ubuntu <span class="hljs-keyword">in</span> ~ <span class="hljs-keyword">at</span> <span class="hljs-number">3</span>BPlus<br>➜ redis-cli -c -p <span class="hljs-number">6001</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; SUBSCRIBE queue<br>Reading messages... (press Ctrl-C <span class="hljs-keyword">to</span> quit)<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;subscribe&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue&quot;</span><br><span class="hljs-number">3</span>) (<span class="hljs-built_in">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;msg1&quot;</span><br><br><span class="hljs-comment"># 生产者</span><br>ubuntu <span class="hljs-keyword">in</span> ~ <span class="hljs-keyword">at</span> <span class="hljs-number">3</span>BPlus<br>➜ redis-cli -c -p <span class="hljs-number">6001</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; PUBLISH queue msg1<br>(<span class="hljs-built_in">integer</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; PUBLISH queue msg2<br>(<span class="hljs-built_in">integer</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; <span class="hljs-keyword">exit</span><br><br><span class="hljs-comment"># Pub/Sub 支持阻塞式拉取消息，满足多组消费者，匹配订阅模式,允许消费者订阅多个队列</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; PUBLISH queue.p1 msg1       <span class="hljs-comment">-- 生产者</span><br>(<span class="hljs-built_in">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; PUBLISH queue.p2 msg2<br>(<span class="hljs-built_in">integer</span>) <span class="hljs-number">1</span><br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6001</span>&gt; PSUBSCRIBE queue.*          <span class="hljs-comment">-- 消费者 匹配订阅</span><br>Reading messages... (press Ctrl-C <span class="hljs-keyword">to</span> quit)<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;psubscribe&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue.*&quot;</span><br><span class="hljs-number">3</span>) (<span class="hljs-built_in">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;pmessage&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue.*&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;queue.p1&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;msg1&quot;</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;pmessage&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;queue.*&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;queue.p2&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;msg2&quot;</span><br><br><span class="hljs-comment"># Pub/Sub 实现原理</span><br>&gt; 没有基于任何数据类型，没有做任何数据存储，只是单纯地为生产者、消费者建立数据转发通道，把符合规则的数据，从一端转发到另一端<br>&gt; **在使用Pub/Sub时，消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失**<br>&gt; List属于“拉取模式”, Pub/Sub属于“推模式”<br><br><span class="hljs-comment"># 注意使用Pub/Sub会丢数据</span><br><span class="hljs-number">1.</span> 消费者下线,重新上线，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，会被丢弃掉.<br><span class="hljs-number">2.</span> Redis宕机, Pub/Sub相关操作，不会写入RDB和AOF中，当Redis宕机重启，Pub/Sub的数据会全部丢失<br><span class="hljs-number">3.</span> 消费堆积, 每个消费者订阅一个队列，Redis都会在Server给消费者分配一个【缓冲区】,这个缓冲区其实就是一块内存，当生产者发布消息时，Redis先把消息写到对应消费者的缓冲区,之后消费者不断从缓冲区读取、处理消息, 缓冲区上线,会被强制下线.<br></code></pre></td></tr></table></figure></li>
<li><p>Stream</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment"># Stream 通过XADD 和 XREAD完成简单的生产、消费模型</span><br>  XADD: 发布消息<br>  XREAD: 读取消息<br><br><span class="hljs-comment"># 生产者发布消息</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6001</span>&gt; XADD <span class="hljs-keyword">queue</span> * name <span class="hljs-number">2021</span>      <span class="hljs-comment"># * 表示自动生成唯一消息ID</span><br>-&gt; Redirected <span class="hljs-keyword">to</span> slot [<span class="hljs-number">13011</span>] located at <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span><br><span class="hljs-string">&quot;1630886765690-0&quot;</span>                           <span class="hljs-comment">#消息ID格式: 时间戳-自增序号</span><br><span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XADD <span class="hljs-keyword">queue</span> * name <span class="hljs-number">09</span>-<span class="hljs-number">06</span><br><span class="hljs-string">&quot;1630886777470-0&quot;</span><br><span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt;<br><br><span class="hljs-comment"># 消费者消费消息</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6001</span>&gt; XREAD COUNT <span class="hljs-number">5</span> STREAMS <span class="hljs-keyword">queue</span> <span class="hljs-number">0</span>-<span class="hljs-number">0</span>   <span class="hljs-comment"># 从开头读取5条消息，0-0表示从开头读取</span><br>-&gt; Redirected <span class="hljs-keyword">to</span> slot [<span class="hljs-number">13011</span>] located at <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span><br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;queue&quot;</span><br>   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886765690-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2021&quot;</span><br>      <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886777470-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;09-06&quot;</span><br><span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XREAD COUNT <span class="hljs-number">5</span> STREAMS <span class="hljs-keyword">queue</span> <span class="hljs-number">1630886777470</span>-<span class="hljs-number">0</span>  <span class="hljs-comment"># 继续拉取消息,传入上一条消息的ID</span><br><span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XREAD COUNT <span class="hljs-number">5</span> BLOCK <span class="hljs-number">0</span> STREAMS <span class="hljs-keyword">queue</span> <span class="hljs-number">1630886777470</span>-<span class="hljs-number">0</span>  <span class="hljs-comment"># BLOCK 阻塞式拉取消息</span><br><br><span class="hljs-comment"># Stream 支持发布/订阅模式</span><br>  - XGROUP: 创建消费者组<br>  - XREADGROUP: 在指定消费组下，开启消费者拉取消息<br><br>  <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XGROUP CREATE <span class="hljs-keyword">queue</span> group1 <span class="hljs-number">0</span>-<span class="hljs-number">0</span>  <span class="hljs-comment"># 创建消费者组1， 0-0表示从头拉取消费</span><br>  OK<br>  <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XGROUP CREATE <span class="hljs-keyword">queue</span> group2 <span class="hljs-number">0</span>-<span class="hljs-number">0</span>  <span class="hljs-comment"># 创建消费者组2，0-0</span><br>  OK<br><br>  <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XREADGROUP GROUP group1 consumer COUNT <span class="hljs-number">5</span> STREAMS <span class="hljs-keyword">queue</span> &gt;  <span class="hljs-comment"># group1 的consumer开始消费，&gt;表示拉取最新数据</span><br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;queue&quot;</span><br>   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886765690-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2021&quot;</span><br>      <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886777470-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;09-06&quot;</span><br>      <span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630887243865-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;08-14&quot;</span><br>  <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XREADGROUP GROUP group2 consumer COUNT <span class="hljs-number">5</span> STREAMS <span class="hljs-keyword">queue</span> &gt;<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;queue&quot;</span><br>   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886765690-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2021&quot;</span><br>      <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630886777470-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;09-06&quot;</span><br>      <span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1630887243865-0&quot;</span><br>         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br>            <span class="hljs-number">2</span>) <span class="hljs-string">&quot;08-14&quot;</span><br>  <span class="hljs-number">172.30</span>.<span class="hljs-number">1.23</span>:<span class="hljs-number">6003</span>&gt; XACK <span class="hljs-keyword">queue</span> group1 <span class="hljs-number">1630887243865</span>-<span class="hljs-number">0</span>  <span class="hljs-comment"># XACK 命令告知Redis消费者处理完</span><br>  (integer) <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Stream 数据会写入RDB和AOF做持久化A</span><br><span class="hljs-comment"># 消息堆积，Stream会只保留固定长度的新消息,当队列长度超过上限，就消息会被删除，只保留固定长度的新消息</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis面试"><a href="#Redis面试" class="headerlink" title="Redis面试"></a>Redis面试</h2><ul>
<li>击穿、穿透、雪崩?<ul>
<li>击穿<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 击穿发生的原因?</span><br>  - <span class="hljs-built_in">Key</span>过期<br>    &gt; <span class="hljs-built_in">Key</span>有过期时间，如果某一个时刻<span class="hljs-built_in">Key</span>失效，那么之后的查询请求将全部压倒数据库上，导致数据库崩溃.<br>  - <span class="hljs-built_in">Key</span>被页面置换淘汰<br>    &gt; 内存有限，要时刻缓存新的数据，淘汰旧的数据<br><br><span class="hljs-meta"># 应对击穿的处理思路?</span><br>  &gt; 由于<span class="hljs-built_in">Key</span>过期在所难免，大流量来到Redis时，根据Redis的单线程特性，可以认为任务是在队列里一次执行，当请求到达redis发现<span class="hljs-built_in">key</span>过期，进行一个操作: 设置锁<br>    <span class="hljs-number">1.</span>请求到达Redis，发现Redis <span class="hljs-built_in">Key</span>过期，查看有没有锁，没有锁的话回到队列后面排队<br>    <span class="hljs-number">2.</span>设置锁，注意，这儿应该是<span class="hljs-built_in">setnx</span>(),而不是<span class="hljs-built_in">set</span>(),因为可能有其他县城已经设置锁了<br>    <span class="hljs-number">3.</span>获取锁，拿到就去数据库取数据，请求返回后释放锁<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>穿透</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">穿透主要原因是很多请求都在访问数据库不存在的数据，应对这种请求的处理办法对访问请求加一层过滤器(布隆过滤器、增强版布隆过滤器、布谷鸟过滤器)</span><br></code></pre></td></tr></table></figure></li>
<li><p>雪崩</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">&gt; 雪崩和击穿类似，不同的是击穿是一个热点<span class="hljs-built_in">Key</span>某时刻失效，而雪崩是大量的热点<span class="hljs-built_in">Key</span>在一瞬间失效<br><br><span class="hljs-meta"># 处理思路?</span><br>  <span class="hljs-number">1.</span> 查看<span class="hljs-built_in">Key</span>过期是不是时点性有关，时点性无关的话，可以随机过期时间解决<br>  <span class="hljs-number">2.</span> 如果是时点性有关，利用强依赖击穿方案，单飞策略(先过去的线程更新一下所有<span class="hljs-built_in">Key</span>,在后台更新热点<span class="hljs-built_in">Key</span>的同时，业务层将进来的请求延时一下)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Middleware/">Middleware</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/03/Dev-Ops-Tips-Tracks/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dev-Ops Tips & Tracks</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/02/Kafka-Tips-Tracks/">
                        <span class="hidden-mobile">Kafka Tips & Tracks</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
