<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>micro-services</title>
    <url>/2021/09/01/micro-services/</url>
    <content><![CDATA[<p>介绍微服务架构设计</p>
<span id="more"></span>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>DDD</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next-gitalk</title>
    <url>/2021/09/01/hexo-next-gitalk/</url>
    <content><![CDATA[<h3 id="站点搭建过程"><a href="#站点搭建过程" class="headerlink" title="站点搭建过程"></a>站点搭建过程</h3><ul>
<li><a href="https://hexo.io/zh-cn/">hexo</a> : 快速、简洁且高校的博客框架</li>
<li><a href="https://github.com/next-theme/hexo-theme-next/blob/master/docs/zh-CN/README.md">next</a> : Hexo主题</li>
<li><a href="https://github.com/gitalk/gitalk">gitalk</a> : 依靠GitHub issue的评论系统</li>
</ul>
<span id="more"></span>

<h3 id="Settings-amp-Tips"><a href="#Settings-amp-Tips" class="headerlink" title="Settings &amp; Tips"></a>Settings &amp; Tips</h3><ul>
<li><strong>Show descripion</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改themes/next/_config.yml</span><br><span class="line">excerpt_description: true</span><br><span class="line"></span><br><span class="line"># 文章截断</span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Tips &amp; Tricks</title>
    <url>/2021/09/01/docker/</url>
    <content><![CDATA[<h2 id="Docker-Info"><a href="#Docker-Info" class="headerlink" title="Docker  Info"></a>Docker  Info</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”</span><br><span class="line"></span><br><span class="line">Cgroups技术是用来制造约束的主要手段</span><br><span class="line">Namespace技术则是用来修改进程试图的主要方法</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Docker-Tips"><a href="#Docker-Tips" class="headerlink" title="Docker Tips"></a>Docker Tips</h2><ul>
<li><p><strong>Docker Tip #1</strong>: Docker 容器进程</p>
<blockquote>
<p>A Docker container is just a process/service that runs directly on your machine. It is slightly different than a regular process because the Docker daemon along with the linux kernel do a few things(<strong>Cgroups</strong>、<strong>Namespace</strong>) to ensure it runs in total isolation<br>Docker容器是一种特殊的进程,和虚拟机差别很大</p>
</blockquote>
</li>
<li><p><strong>Docker Tip #2</strong>: COPY vs. ADD in a Dockerfile</p>
<blockquote>
<p>COPY 和 ADD 功能很相似，都可以从指定目录拷贝数据到Docker镜像中.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># COPY 和 ADD 区别</span><br><span class="line">1. COPY: 只能从本机文件或目录中拷贝到镜像中</span><br><span class="line">2. ADD: 不仅可以从本机文件或目录中拷贝，还可以使用URL引入外部的文件地址拷贝到镜像中</span><br><span class="line">  $ ADD rootfs.tar.gz /</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #3</strong>: 追加 Docker Run 指令减少镜像大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Before Dockerfile -- 新增三个层lager</span><br><span class="line">RUN wget -O myfile.tar.gz http://example.com/myfile.tar.gz</span><br><span class="line">RUN tar -xvf myfile.tar.gz -C /usr/src/myapp</span><br><span class="line">RUN rm myfile.tar.gz</span><br><span class="line"></span><br><span class="line"># After Dockerfile -- 新增一个层layer</span><br><span class="line">RUN wget -O myfile.tar.gz http://example.com/myfile.tar.gz \</span><br><span class="line">  &amp;&amp; tar -xvf myfile.tar.gz -C /usr/src/myapp \</span><br><span class="line">  &amp;&amp; rm myfile.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #4</strong>: Docker Base镜像OS和Host OS没有关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker Image OS: 定义在Dockerfile文件的Base镜像的系统</span><br><span class="line">Host OS: 运行Docker image的环境</span><br><span class="line">You can use whatever base image you want for your Docker images.</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #5</strong>: 使用相同Base镜像的好处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You could use a different base OS for each Docker image, but then you lose out on the ability to cache it across all of your images</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #6</strong>: RUN vs. CMD in a Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN: 在镜像内执行命令，这些指令仅仅在构建build镜像中执行一次，并且将构建结果写入新larger层中.</span><br><span class="line">CMD: 在启动容器时定义默认的运行的指令, 这种动作发生运行时run-time</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #7</strong>: Base Docker Image Alpine</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Why Alpine?</span><br><span class="line">&gt; Small. Simple. Secure. Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox.</span><br><span class="line">&gt; Alpine is about 30x smaller than Debian.</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #8</strong>: Project Structure with Multiple Dockerfiles and Docker Compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu in ~/chyi/micro-services at 3BPlus on 🐳 v20.10.8</span><br><span class="line">➜ tree -L 2</span><br><span class="line">.</span><br><span class="line">├── auth</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">├── billing</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">├── contact</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── user</span><br><span class="line">    └── Dockerfile</span><br><span class="line"></span><br><span class="line">4 directories, 5 files</span><br><span class="line"></span><br><span class="line">The docker-compose.yaml</span><br><span class="line">ubuntu in ~/chyi/micro-services at 3BPlus on 🐳 v20.10.8</span><br><span class="line">➜ cat docker-compose.yml</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    auth:</span><br><span class="line">        build: &#x27;./auth&#x27;</span><br><span class="line">    billing:</span><br><span class="line">        build: &#x27;./billing&#x27;</span><br><span class="line">    contact:</span><br><span class="line">        build: &#x27;./contact&#x27;</span><br><span class="line">    user:</span><br><span class="line">        build: &#x27;./user&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #9</strong>: 使用Volumes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker-compose.yaml</span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    # Mount the crrent directoy into `/app` inside the running container.</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x27;.:/app&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #10</strong>: Published Ports</p>
<blockquote>
<p>Creates a firwaall rule which maps a container port to a port on the Docker host to the outside world.</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Flag value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-p 8080:80</td>
<td align="left">Map TCP port 80 in the container to port 8080 on the Docker host.</td>
</tr>
<tr>
<td align="left">-p 192.168.1.100:8080:80</td>
<td align="left">Map TCP port 80 in the container to port 8080 on the Docker host for connections to host IP 192.168.1.100.</td>
</tr>
<tr>
<td align="left">-p 8080:80/udp</td>
<td align="left">Map UDP port 80 in the container to port 8080 on the Docker host.</td>
</tr>
<tr>
<td align="left">-p 8080:80/tcp -p 8080:80/udp</td>
<td align="left">Map TCP port 80 in the container to TCP port 8080 on the Docker host, and map UDP port 80 in the container to UDP port 8080 on the Docker host.</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>Docker Tip #11</strong>: dockerignore file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.dockerignore: ignore certain files and folders from your Docker images</span><br><span class="line">  .git</span><br><span class="line">  .dockerignore</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Docker Tip #12</strong>: Manage Docker without sudo on Linux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add a docker group and then add your user to it:</span><br><span class="line">$ sudo groupadd docker</span><br><span class="line">$ docker usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
</search>
